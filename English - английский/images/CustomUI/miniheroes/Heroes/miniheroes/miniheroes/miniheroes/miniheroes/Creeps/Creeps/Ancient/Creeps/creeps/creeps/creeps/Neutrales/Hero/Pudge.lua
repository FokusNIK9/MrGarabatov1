local PudgeBeta1 = {}  Log.Write("Loaded script: Pudgev1.lua")   local log = function(msg)  	Log.Write(tostring(msg)) end  function GetIconPath( name, ... ) 	return 'panorama/images/heroes/icons/npc_dota_hero_' .. name .. '_png.vtex_c' end  local OverallPath = {} OverallPath[1] = { "MrGarabato", "Select Hero"  } OverallPath[2] = { "MrGarabato", "Select Hero" , "Target selector" } OverallPath[3] = { "MrGarabato", "Select Hero" , "Target selector", "Target exclusions" } OverallPath[6] = { "MrGarabato", "Select Hero" , "Orbwalker" } OverallPath[7] = { "MrGarabato", "Select Hero" , "Orbwalker", "Orbwalk to enemy options" } OverallPath[8] = { "MrGarabato", "Select Hero" , "Orbwalker", "Orbwalk to mouse options" }   OverallPath[16] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items" } OverallPath[17] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items", "Combo usage" } OverallPath[18] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items", "Combo usage", "Items" } OverallPath[19] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items", "Auto Usage", "Armlet" } OverallPath[20] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items", "Auto Usage", "Hurricane Pike" } OverallPath[21] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items", "Auto Usage", "Blade Mail" } OverallPath[22] = { "MrGarabato", "Select Hero" , "Item Usage", "Offensive items", "OnUnitOrder Usage" } OverallPath[23] = { "MrGarabato", "Select Hero" , "Item Usage", "Linkens breaker" } OverallPath[24] = { "MrGarabato", "Select Hero" , "Item Usage", "Utility Items" } OverallPath[25] = { "MrGarabato", "Select Hero" , "Item Usage", "Defensive Items" } OverallPath[26] = { "MrGarabato", "Select Hero" , "Item Usage", "Defensive Items", "BKB" } OverallPath[43] = { "MrGarabato", "Select Hero"  } OverallPath[45] = { "MrGarabato", "Select Hero" , "Farm and AutoSuicide" } OverallPath[46] = { "MrGarabato", "Select Hero" , "Misc2" } OverallPath[111] = { "MrGarabato", "Select Hero" , "Items Initiation" } OverallPath[666] = { "Support", "Auto section" , "Auto purchase","TOME","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros","Otros" }  Menu.AddMenuIcon({"MrGarabato", "Select Hero" }, "~/panorama/images/heroes/icons/npc_dota_hero_pudge_png.png")	   PudgeBeta1.optionHeroPudgeHookComboMaxRange = Menu.AddOptionSlider(OverallPath[1], "Max hook range in combo without items",  250, 1550, 1225) PudgeBeta1.optionHeroPudgeHookCombo = Menu.AddOptionBool(OverallPath[1], "Activation hooks ", true)  Menu.AddMenuIcon({"MrGarabato", "Select Hero" , "Target selector"}, "panorama/images/icon_plus_white_png.vtex_c") Menu.AddMenuIcon({"MrGarabato", "Select Hero" , "Items Initiation"}, "panorama/images/icon_plus_white_png.vtex_c")   PudgeBeta1.optionTargetStyle = Menu.AddOptionCombo(OverallPath[2], "Targeting style", {'locked target', 'free target'}, 1) PudgeBeta1.optionTargetRange = Menu.AddOptionSlider(OverallPath[2], "Target acquisition range",  200, 1000, 900) PudgeBeta1.optionMoveToCursor = Menu.AddOptionBool(OverallPath[2], "Move to Cursor Pos", true) PudgeBeta1.optionLockTargetIndicator = Menu.AddOptionBool(OverallPath[2], "Draw target indicator", true) PudgeBeta1.optionLockTargetParticle = Menu.AddOptionCombo(OverallPath[2], "Indicator style", {'blinding light', 'blood bath', 'tower aggro'}, 2) PudgeBeta1.optionTargetCheckAM = Menu.AddOptionBool(OverallPath[3], "Enable", true) PudgeBeta1.optionTargetCheckLotus = Menu.AddOptionBool(OverallPath[3], "Exclude active lotus orb", true) PudgeBeta1.optionTargetCheckBlademail = Menu.AddOptionBool(OverallPath[3], "Exclude blademail", false) PudgeBeta1.optionTargetCheckNyx = Menu.AddOptionBool(OverallPath[3], "Exclude spiked carapace", false) PudgeBeta1.optionTargetCheckUrsa = Menu.AddOptionBool(OverallPath[3], "Exclude enraged ursa", false) PudgeBeta1.optionTargetCheckAbbadon = Menu.AddOptionBool(OverallPath[3], "Exclude abaddon ult", false) PudgeBeta1.optionTargetCheckDazzle = Menu.AddOptionBool(OverallPath[3], "Exclude shallow grave", false)  PudgeBeta1.optionHeroPudgeBlink = Menu.AddOptionBool(OverallPath[111], "Use blink for initiation", true) PudgeBeta1.optionHeroPudgeBlinkMinRange = Menu.AddOptionSlider(OverallPath[111], "Blink min. range ",  250, 1200, 500) PudgeBeta1.optionHeroPudgeStaff = Menu.AddOptionBool(OverallPath[111], "Use force staff for initiation", false)  PudgeBeta1.optionHeroPudgeHook = Menu.AddOptionBool(OverallPath[666], "Enable hook helper ",true) PudgeBeta1.optionHeroPudgeHookKey = Menu.AddKeyOption(OverallPath[43], "2) Combo Key with items ", Enum.ButtonCode.KEY_NONE) Menu.AddOptionIcon(PudgeBeta1.optionHeroPudgeHookKey, "panorama/images/icon_treasure_arrow_psd.vtex_c") PudgeBeta1.optionHeroPudgeHookAcquiRange = Menu.AddOptionSlider(OverallPath[43], "Max hook range in combo with items ",  250, 1200, 1000)  PudgeBeta1.optionHeroPudgeHookAllies = Menu.AddOptionBool(OverallPath[666], "2.1 Also target allies {{pudge hook}}", false) PudgeBeta1.optionHeroPudgeHookStaff = Menu.AddOptionBool(OverallPath[666], "2.2 Use force staff to avoid collision {{pudge hook}}", false) PudgeBeta1.optionHeroPudgeHookUlt = Menu.AddOptionBool(OverallPath[666], "3. Use dismember {{pudge hook}}", true) PudgeBeta1.optionHeroPudgeHookRot = Menu.AddOptionBool(OverallPath[666], "4. Use rot {{pudge hook}}", true) PudgeBeta1.optionHeroPudgeHookItems = Menu.AddOptionBool(OverallPath[666], "5. Use offensive items {{pudge hook}}", true) PudgeBeta1.optionHeroPudgeHookJuke = Menu.AddOptionSlider(OverallPath[43], " Anti-juke-offset",  0, 12, 8) PudgeBeta1.optionHeroPudgeFarm = Menu.AddOptionBool(OverallPath[666], "Rot farm ","") PudgeBeta1.optionHeroPudgeFarmHP = Menu.AddOptionSlider(OverallPath[666], "Rot farm HP treshold", 5, 75, 7) PudgeBeta1.optionHeroPudgeSuicide = Menu.AddOptionBool(OverallPath[666], "Auto suicide", "")   local Wrap = require("images/CustomUI/miniheroes/Heroes/miniheroes/miniheroes/miniheroes/miniheroes/Creeps/Creeps/Ancient/Creeps/creeps/creeps/creeps/Neutrales/Hero/Key/WrapUtility")  PudgeBeta1.optionItemEnable = Menu.AddOptionBool(OverallPath[666], "0. Enabled {{off items}}", false) PudgeBeta1.optionItemStyle = Menu.AddOptionCombo(OverallPath[666], "Choose activation style", {'max speed, no order','ordered','smart ordered'}, 1) PudgeBeta1.optionItemStack = Menu.AddOptionBool(OverallPath[666], "Stack hex and silence", false) PudgeBeta1.optionItemSoulring = Menu.AddOptionBool(OverallPath[666], "Soulring", false) PudgeBeta1.optionItemVeil = Menu.AddOptionSlider(OverallPath[666], "Use Item Veil Of Discord",  0, 18, 18) PudgeBeta1.optionItemHex = Menu.AddOptionSlider(OverallPath[666], "Use Item Scythe Of Vyse",  0, 18, 18) PudgeBeta1.optionItemBlood = Menu.AddOptionSlider(OverallPath[666], "Use Item Bloodthorn ",  0, 18, 18) PudgeBeta1.optionItemeBlade = Menu.AddOptionSlider(OverallPath[666], "Use Item Ethereal Blade",  0, 18, 18) PudgeBeta1.optionItemOrchid = Menu.AddOptionSlider(OverallPath[666], "Use Item Orchid Malevolence",  0, 18, 18) PudgeBeta1.optionItemAtos = Menu.AddOptionSlider(OverallPath[666], "Use Item Rod Of Atos",  0, 18, 1) PudgeBeta1.optionItemAbyssal = Menu.AddOptionSlider(OverallPath[666], "Use Item Abyssal Blade",  0, 18, 1) PudgeBeta1.optionItemHalberd = Menu.AddOptionSlider(OverallPath[666], "Use Item Heavens Halbert",  0, 18, 1) PudgeBeta1.optionItemShivas = Menu.AddOptionSlider(OverallPath[666], "Use Item Shivas Guard",  0, 18, 18) PudgeBeta1.optionItemDagon = Menu.AddOptionSlider(OverallPath[666], "Use Item Dagon",  -1, 18, 18) PudgeBeta1.optionItemUrn = Menu.AddOptionSlider(OverallPath[666], "Use Item Urn of shadows",  0, 18, 1) PudgeBeta1.optionItemManta = Menu.AddOptionSlider(OverallPath[666], "Use Item Manta Style",  0, 18, 1) PudgeBeta1.optionItemMjollnir = Menu.AddOptionSlider(OverallPath[666], "Use Item Mjollnir",  0, 18, 1) PudgeBeta1.optionItemMedallion = Menu.AddOptionSlider(OverallPath[666], "Use Item Medallion of Courage",  0, 18, 1) PudgeBeta1.optionItemCrest = Menu.AddOptionSlider(OverallPath[666], "Use Item Solar Crest",  0, 18, 18) PudgeBeta1.optionItemSpirit = Menu.AddOptionSlider(OverallPath[666], "Use Item Spirit Vessel",  0, 18, 1) PudgeBeta1.optionItemNull = Menu.AddOptionSlider(OverallPath[666], "Use Item Nullifier",  0, 18, 1) PudgeBeta1.optionItemDiffusal = Menu.AddOptionSlider(OverallPath[666], "Use Item Diffusal Blade",  0, 18, 1) PudgeBeta1.optionItemArmlet = Menu.AddOptionBool(OverallPath[666], "0. Enable {{armlet}}", false) PudgeBeta1.optionItemArmletHPTreshold = Menu.AddOptionSlider(OverallPath[666], "1. HP threshold {{armlet}}", 100, 500, 50) PudgeBeta1.optionItemArmletCombo = Menu.AddOptionBool(OverallPath[666], "2. Combo usage {{armlet}}", false) PudgeBeta1.optionItemArmletRightClick = Menu.AddOptionBool(OverallPath[666], "3. Right click activation {{armlet}}", false) PudgeBeta1.optionItemArmletRightClickStyle = Menu.AddOptionCombo(OverallPath[666], "3.1 Right click style {{armlet}}", {'single click', 'double click'}, 1) PudgeBeta1.optionItemArmletIllusion = Menu.AddOptionBool(OverallPath[666], "4. Illusion activation {{armlet}}", false) PudgeBeta1.optionItemArmletManuallyOverride = Menu.AddOptionBool(OverallPath[666], "5. Manual override {{armlet}}", false) PudgeBeta1.optionItemHurricane = Menu.AddOptionBool(OverallPath[666], "0. Enable {{hurricane}}", false) PudgeBeta1.optionItemHurricaneHP = Menu.AddOptionSlider(OverallPath[666], "1. HP treshold {{hurricane}}", 5 ,75, 5) PudgeBeta1.optionItemBlademail = Menu.AddOptionBool(OverallPath[666], "0. Enable {{blade mail}}", false) PudgeBeta1.optionItemSoulringManual = Menu.AddOptionBool(OverallPath[666], "Soulring {{onunitorder}}", false) PudgeBeta1.optionItemVeilManual = Menu.AddOptionBool(OverallPath[666], "Veil of Discord {{onunitorder}}", false)   PudgeBeta1.optionLinkensEnable = Menu.AddOptionBool(OverallPath[666], "0. Enabled {{linkens}}", false) PudgeBeta1.optionLinkensManual = Menu.AddOptionBool(OverallPath[666], "1. Pop linkens when manually casting", false) PudgeBeta1.optionLinkensForce = Menu.AddOptionSlider(OverallPath[666], "Use Force Staff",  0, 8, 1) PudgeBeta1.optionLinkensEul = Menu.AddOptionSlider(OverallPath[666], "Use Eul",  0, 8, 1) PudgeBeta1.optionLinkensHalberd = Menu.AddOptionSlider(OverallPath[666], "Use Halberd",  0, 8, 1) PudgeBeta1.optionLinkensHex = Menu.AddOptionSlider(OverallPath[666], "Use Hex",  0, 8, 1) PudgeBeta1.optionLinkensBlood = Menu.AddOptionSlider(OverallPath[666], "Use Bloodthorn",  0, 8, 1) PudgeBeta1.optionLinkensOrchid = Menu.AddOptionSlider(OverallPath[666], "Use Orchid",  0, 8, 1) PudgeBeta1.optionLinkensPike = Menu.AddOptionSlider(OverallPath[666], "Use Pike",  0, 8, 1) PudgeBeta1.optionLinkensDiffusal = Menu.AddOptionSlider(OverallPath[666], "Use Diffusal",  0, 8, 1)  PudgeBeta1.optionUtilityEnable = Menu.AddOptionBool(OverallPath[666], "0. Enable auto usage {{util}}", false) PudgeBeta1.optionUtilityMidas = Menu.AddOptionBool(OverallPath[666], "Auto Use Midas", false) PudgeBeta1.optionUtilityStick = Menu.AddOptionBool(OverallPath[666], "Auto Use Stick/Wand/Cheese/Faerie", false) PudgeBeta1.optionUtilityHealth = Menu.AddOptionSlider(OverallPath[666], "1. Treshold Hero Health", 5, 75, 5) PudgeBeta1.optionUtilityMek = Menu.AddOptionBool(OverallPath[666], "Auto Use Mekansm", false) PudgeBeta1.optionUtilityGreaves = Menu.AddOptionBool(OverallPath[666], "Auto Use Greaves", false) PudgeBeta1.optionUtilityArcane = Menu.AddOptionBool(OverallPath[666], "Auto Use Arcane Boots", false) PudgeBeta1.optionUtilityBottle = Menu.AddOptionBool(OverallPath[666], "Auto Use Bottle", false)  PudgeBeta1.optionDefensiveItems = Menu.AddOptionBool(OverallPath[666], "0. Enable auto usage {{deff}}", false) PudgeBeta1.optionDefensiveItemsGlimmer = Menu.AddOptionBool(OverallPath[666], "2. Glimmer Cape", false) PudgeBeta1.optionDefensiveItemslotusOrb = Menu.AddOptionBool(OverallPath[666], "3. Lotus Orb", false) PudgeBeta1.optionDefensiveItemsCrimson = Menu.AddOptionBool(OverallPath[666], "4. Crimson Guard", false) PudgeBeta1.optionDefensiveItemsCrest = Menu.AddOptionBool(OverallPath[666], "5. Solar Crest", false) PudgeBeta1.optionDefensiveItemsPipe = Menu.AddOptionBool(OverallPath[666], "6. Pipe", false) PudgeBeta1.optionDefensiveItemsBKB = Menu.AddOptionBool(OverallPath[666], "0. Enabled {{bkb}}", false) PudgeBeta1.optionDefensiveItemsBKBEnemies = Menu.AddOptionSlider(OverallPath[666], "1. Min. enemies around", 1, 5, 1) PudgeBeta1.optionDefensiveItemsBKBRadius = Menu.AddOptionSlider(OverallPath[666], "2. Search radius", 500, 1000, 100) PudgeBeta1.optionDefensiveItemsSatanic = Menu.AddOptionBool(OverallPath[666], "7. Satanic", false) PudgeBeta1.optionDefensiveItemsThreshold = Menu.AddOptionSlider(OverallPath[666], "0.1 HP Threshold {{deff}}", 10, 50, 5) PudgeBeta1.optionDefensiveItemsThresholdDisable = Menu.AddOptionSlider(OverallPath[666], "0.2 HP Threshold if disabled {{deff}}", 35, 100, 5) PudgeBeta1.optionDefensiveItemsMedallion = Menu.AddOptionBool(OverallPath[666], "8. Medallion of Courage", false) PudgeBeta1.optionDefensiveItemsGhost = Menu.AddOptionBool(OverallPath[666], "9. Ghost scepter", false) PudgeBeta1.optionDefensiveItemsAlly = Menu.AddOptionBool(OverallPath[666], "0.3 Cast defensive items on allies {{deff}}", false) PudgeBeta1.optionDefensiveItemsSaver = Menu.AddOptionBool(OverallPath[666], "0.4 Advanced lotus/glimmer ally saving {{deff}}", false)     local CurentHero = nil PudgeBeta1.LockedTarget = nil PudgeBeta1.myUnitName = nil PudgeBeta1.lastCastTime = 0 PudgeBeta1.lastCastTime2 = 0 PudgeBeta1.lastCastTime3 = 0 PudgeBeta1.lastTick = 0 PudgeBeta1.delay = 0 PudgeBeta1.itemDelay = 0 PudgeBeta1.lastItemCast = 0 PudgeBeta1.lastDefItemPop = 0 PudgeBeta1.lastItemTick = 0 PudgeBeta1.ItemCastStop = false PudgeBeta1.isArmletManuallyToggled = false PudgeBeta1.isArmletManuallyToggledTime = 0 PudgeBeta1.armletDelayer = 0 PudgeBeta1.ControlledUnitCastTime = 0 PudgeBeta1.ControlledUnitPauseTime = 0 PudgeBeta1.lastAttackTime = 0 PudgeBeta1.lastAttackTime2 = 0 PudgeBeta1.LastTarget = nil PudgeBeta1.TempestInAttackBackswing = false PudgeBeta1.TempestOrbwalkerDelay = 0 PudgeBeta1.ArcWardenEntityProjectileCreate = 0 PudgeBeta1.GenericUpValue = false PudgeBeta1.lastPosition = Vector(0, 0, 0) PudgeBeta1.Toggler = false PudgeBeta1.TogglerTime = 0 PudgeBeta1.AttackProjectileCreate = 0 PudgeBeta1.AttackAnimationCreate = 0 PudgeBeta1.AttackParticleCreate = 0 PudgeBeta1.InAttackBackswing = false PudgeBeta1.OrbwalkerDelay = 0 PudgeBeta1.TPParticleIndex = nil PudgeBeta1.TPParticleTime = 0 PudgeBeta1.TPParticleUnit = nil PudgeBeta1.TPParticlePosition = Vector() PudgeBeta1.GlimpseParticleIndex = nil PudgeBeta1.GlimpseParticleTime = 0 PudgeBeta1.GlimpseParticleUnit = nil PudgeBeta1.GlimpseParticlePosition = Vector() PudgeBeta1.GlimpseParticleIndexStart = nil PudgeBeta1.GlimpseParticlePositionStart = Vector() PudgeBeta1.particleNextTime = 0 PudgeBeta1.currentParticle = 0 PudgeBeta1.currentParticleTarget = nil PudgeBeta1.PudgeRotComboActivation = false PudgeBeta1.PudgeRotComboDeactivation = 0 PudgeBeta1.PudgeHookStartTimer = 0 PudgeBeta1.PudgeHookDelayer = 0 PudgeBeta1.PudgeHookRotDelayer = 0 PudgeBeta1.PudgeHookTarget = nil PudgeBeta1.PudgeHookTargetedPos = nil PudgeBeta1.PudgeHookHit = false PudgeBeta1.PudgecurrentParticle = 0 PudgeBeta1.PudgecurrentParticleTarget = nil PudgeBeta1.PudgeRotFarmToggled = false PudgeBeta1.PudgeRotFarmToggledTime = 0  PudgeBeta1.LinkensBreakerItemOrder = {} PudgeBeta1.ItemCastOrder = {} PudgeBeta1.rotationTable = {} PudgeBeta1.enemyHeroTable = {} PudgeBeta1.dodgeItTable = {} PudgeBeta1.dodgeItReadyTable = {} PudgeBeta1.dodgeItSkillReady = {} PudgeBeta1.wardDispenserCount = {} PudgeBeta1.wardProcessingTable = {} PudgeBeta1.lastHitCreepHPPrediction = {} PudgeBeta1.lastHitCreepHPPredictionTime = {} PudgeBeta1.creepAttackPointData = {} PudgeBeta1.heroIconHandler = {} PudgeBeta1.itemIconHandler = {} PudgeBeta1.ControllableEntityTable = {} PudgeBeta1.ControllableAttackTiming = {} PudgeBeta1.TinkerJungleFarmPos = {} PudgeBeta1.JungleTrackTable = {} PudgeBeta1.ShrinePositionTable = {}  PudgeBeta1.heroList = { "npc_dota_hero_pudge"} 			 			 PudgeBeta1.dodgeItItems = {  	{"item_manta", 1, "no target", 0.1},  	{"item_blink", 0, "position", 0.1},  	{"item_cyclone", 0, "target", 0.1}, 	{"item_lotus_orb", 1, "target", 0.1}, 	{"item_black_king_bar", 2, "no target", 0.1}, 	{"item_blade_mail", 0, "no target", 0.1}, 	{"item_glimmer_cape", 0, "target", 0.1} 		}   PudgeBeta1.attackPointTable = { 	npc_dota_hero_pudge = { 0.5, 1.17, 0 }} 	 PudgeBeta1.AbilityList = { 	{ "npc_dota_hero_pudge", "pudge_dismember", "disable", "target" , "0" }, 	{ "npc_dota_hero_pudge", "pudge_flesh_heap", "utility", "0" , "0" }, 	{ "npc_dota_hero_pudge", "pudge_meat_hook", "utility", "0" , "0" }, 	{ "npc_dota_hero_pudge", "pudge_rot", "utility", "0" , "0" }} 	 	 PudgeBeta1.RawDamageAbilityEstimation = {	pudge_dismember = { "target", 0, 0, 75, 0, 0 },	pudge_meat_hook = { "position", 0, 100, 100, 1450, 0 }}  function PudgeBeta1.ResetGlobalVariables() 	CurentHero = nil 	PudgeBeta1.LockedTarget = nil 	PudgeBeta1.myUnitName = nil 	PudgeBeta1.lastCastTime = 0 	PudgeBeta1.lastCastTime2 = 0 	PudgeBeta1.lastCastTime3 = 0 	PudgeBeta1.lastTick = 0 	PudgeBeta1.delay = 0 	PudgeBeta1.itemDelay = 0 	PudgeBeta1.lastItemCast = 0 	PudgeBeta1.lastDefItemPop = 0 	PudgeBeta1.lastItemTick = 0 	PudgeBeta1.ItemCastStop = false 	PudgeBeta1.isArmletManuallyToggled = false 	PudgeBeta1.isArmletManuallyToggledTime = 0 	PudgeBeta1.armletDelayer = 0 	PudgeBeta1.ControlledUnitCastTime = 0 	PudgeBeta1.ControlledUnitPauseTime = 0 	PudgeBeta1.lastAttackTime = 0 	PudgeBeta1.lastAttackTime2 = 0 	PudgeBeta1.LastTarget = nil 	PudgeBeta1.LastTickManta1 = 0 	PudgeBeta1.LastTickManta2 = 0  	PudgeBeta1.TempestOrbwalkerDelay = 0  	PudgeBeta1.GenericUpValue = false 	PudgeBeta1.lastPosition = Vector(0, 0, 0)  	PudgeBeta1.Toggler = false 	PudgeBeta1.TogglerTime = 0  	PudgeBeta1.AttackProjectileCreate = 0 	PudgeBeta1.AttackAnimationCreate = 0 	PudgeBeta1.AttackParticleCreate = 0 	PudgeBeta1.InAttackBackswing = false 	PudgeBeta1.OrbwalkerDelay = 0 	PudgeBeta1.TPParticleIndex = nil 	PudgeBeta1.TPParticleTime = 0 	PudgeBeta1.TPParticleUnit = nil 	PudgeBeta1.TPParticlePosition = Vector() 	PudgeBeta1.GlimpseParticleIndex = nil 	PudgeBeta1.GlimpseParticleTime = 0 	PudgeBeta1.GlimpseParticleUnit = nil 	PudgeBeta1.GlimpseParticlePosition = Vector() 	PudgeBeta1.GlimpseParticleIndexStart = nil 	PudgeBeta1.GlimpseParticlePositionStart = Vector() 	PudgeBeta1.particleNextTime = 0 	PudgeBeta1.currentParticle = 0 	PudgeBeta1.currentParticleTarget = nil  	PudgeBeta1.dodgeTiming = 0 	PudgeBeta1.dodgerProjectileAdjustmentTick = 0 	PudgeBeta1.saverTiming = 0  	PudgeBeta1.PudgeRotComboActivation = false 	PudgeBeta1.PudgeRotComboDeactivation = 0 	PudgeBeta1.PudgeHookStartTimer = 0 	PudgeBeta1.PudgeHookDelayer = 0 	PudgeBeta1.PudgeHookRotDelayer = 0 	PudgeBeta1.PudgeHookTarget = nil 	PudgeBeta1.PudgeHookTargetedPos = nil 	PudgeBeta1.PudgeHookHit = false 	PudgeBeta1.PudgecurrentParticle = 0 	PudgeBeta1.PudgecurrentParticleTarget = nil 	PudgeBeta1.PudgeRotFarmToggled = false 	PudgeBeta1.PudgeRotFarmToggledTime = 0   	PudgeBeta1.ShrinePositionTable = {}  	PudgeBeta1.lastHitCreepHPPrediction = {} 	PudgeBeta1.lastHitCreepHPPredictionTime = {} 	PudgeBeta1.creepAttackPointData = {} 	PudgeBeta1.dodgeItTable = {} 	PudgeBeta1.dodgeItSkillReady = {} 	PudgeBeta1.dodgeItReadyTable = {} 	PudgeBeta1.LinkensBreakerItemOrder = {} 	PudgeBeta1.ItemCastOrder = {} 	PudgeBeta1.rotationTable = {}  	PudgeBeta1.enemyHeroTable = {}    	PudgeBeta1.heroIconHandler = {} 	PudgeBeta1.itemIconHandler = {} 	PudgeBeta1.ControllableEntityTable = {} 	PudgeBeta1.ControllableAttackTiming = {}  end  function PudgeBeta1.OnGameStart() 	 	PudgeBeta1.ResetGlobalVariables()  end  function PudgeBeta1.OnGameEnd() 	 	PudgeBeta1.ResetGlobalVariables()  end  function PudgeBeta1.OnUpdate()     if not Menu.IsEnabled(MrGarabato_v1_MenuHx.optionEnable) then return true end     if not Menu.IsEnabled(MrGarabato_v1_MenuHx.EnableHero) then return end 	if not Engine.IsInGame() then 		PudgeBeta1.ResetGlobalVariables() 	end 	 	if GameRules.GetGameState() < 4 then return end 	if GameRules.GetGameState() > 5 then return end  	local myHero = Heroes.GetLocal() 		if not myHero then return end 		if not Wrap.EIsAlive(myHero) then return end 		if PudgeBeta1.myUnitName == nil then 			PudgeBeta1.myUnitName = NPC.GetUnitName(myHero) 		end 			if next(PudgeBeta1.ItemCastOrder) == nil then 		PudgeBeta1.setOrderItem(false) 	end  	if next(PudgeBeta1.LinkensBreakerItemOrder) == nil then 		PudgeBeta1.setOrderLinkens(false) 	end  	local isHeroSupported = PudgeBeta1.heroSupported(myHero)  	local enemy = PudgeBeta1.getComboTarget(myHero)  	if Menu.IsKeyDown(MrGarabato_v1_MenuHx.optionComboKey) then 		if Menu.GetValue(PudgeBeta1.optionTargetStyle) < 1 then 			if PudgeBeta1.LockedTarget == nil then 				if enemy then 					PudgeBeta1.LockedTarget = enemy 				else 					PudgeBeta1.LockedTarget = nil 				end 			end 		else 			if enemy then 				PudgeBeta1.LockedTarget = enemy 			else 				PudgeBeta1.LockedTarget = nil 			end 		end 	else 		PudgeBeta1.LockedTarget = nil 	end  	if PudgeBeta1.LockedTarget ~= nil then 		if not Wrap.EIsAlive(PudgeBeta1.LockedTarget) then 			PudgeBeta1.LockedTarget = nil 		elseif Entity.IsDormant(PudgeBeta1.LockedTarget) then 			PudgeBeta1.LockedTarget = nil 		elseif not NPC.IsEntityInRange(myHero, PudgeBeta1.LockedTarget, 3000) then 			PudgeBeta1.LockedTarget = nil 		end 	end  	if Menu.IsEnabled(PudgeBeta1.optionLockTargetIndicator) then 		PudgeBeta1.TargetIndicator(myHero) 	end  	local comboTarget 		if PudgeBeta1.LockedTarget ~= nil then 			comboTarget = PudgeBeta1.LockedTarget 		else 			if not Menu.IsKeyDown(MrGarabato_v1_MenuHx.optionComboKey) then 				comboTarget = enemy 			end 		end 			 	if PudgeBeta1.myUnitName == "npc_dota_hero_pudge" then 		PudgeBeta1.PudgeCombo(myHero, comboTarget) 	end 	 	 	if Menu.IsEnabled(PudgeBeta1.optionUtilityEnable) then 		PudgeBeta1.utilityItemUsage(myHero) 	    end 		 		if PudgeBeta1.LockedTarget == nil then 		if Menu.IsEnabled(PudgeBeta1.optionMoveToCursor) then 			if Menu.IsKeyDown(MrGarabato_v1_MenuHx.optionComboKey) then 				PudgeBeta1.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos()) 				return 			end      end  end end   function PudgeBeta1.utilityItemUsage(myHero)  	if not myHero then return end  	if PudgeBeta1.heroCanCastItems(myHero) == false then return end 	if PudgeBeta1.isHeroChannelling(myHero) == true then return end   	local stick = NPC.GetItem(myHero, "item_magic_stick", true) 	local wand = NPC.GetItem(myHero, "item_magic_wand", true) 	local mekansm = NPC.GetItem(myHero, "item_mekansm", true) 	local greaves = NPC.GetItem(myHero, "item_guardian_greaves", true) 	local arcane = NPC.GetItem(myHero, "item_arcane_boots", true) 	local midas = NPC.GetItem(myHero, "item_hand_of_midas", true) 	local cheese = NPC.GetItem(myHero, "item_cheese", true) 	local faerie = NPC.GetItem(myHero, "item_faerie_fire", true) 	local bottle = NPC.GetItem(myHero, "item_bottle", true)  	local myMana = NPC.GetMana(myHero)  	if (stick or wand or cheese or faerie) and Menu.IsEnabled(PudgeBeta1.optionUtilityStick) then 		PudgeBeta1.utilityItemStick(myHero, stick, wand, cheese, faerie) 	end 	if mekansm and Menu.IsEnabled(PudgeBeta1.optionUtilityMek) then 		PudgeBeta1.utilityItemMek(myHero, mekansm, myMana) 	end 	if greaves and Menu.IsEnabled(PudgeBeta1.optionUtilityGreaves) then 		PudgeBeta1.utilityItemGreaves(myHero, greaves) 	end 	if arcane and Menu.IsEnabled(PudgeBeta1.optionUtilityArcane) then 		PudgeBeta1.utilityItemArcane(myHero, arcane) 	end 	if midas and Menu.IsEnabled(PudgeBeta1.optionUtilityMidas) then 		PudgeBeta1.utilityItemMidas(myHero, midas) 	end 	if bottle and Menu.IsEnabled(PudgeBeta1.optionUtilityBottle) then 		PudgeBeta1.utilityItemBottle(myHero, bottle) 	end  end   function PudgeBeta1.heroCanCastItems(myHero)  	if not myHero then return false end 	if not Wrap.EIsAlive(myHero) then return false end  	if NPC.IsStunned(myHero) then return false end 	if NPC.HasModifier(myHero, "modifier_bashed") then return false end 	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	 	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end 	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end 	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	 	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end 	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end 	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end 	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end 	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end 	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end 	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end 	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end 	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end 	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end 	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end 	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end 	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end 	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end 	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end 	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end 	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end  	return true	  end   function PudgeBeta1.isHeroChannelling(myHero)  	if not myHero then return true end  	if NPC.IsChannellingAbility(myHero) then return true end 	if NPC.HasModifier(myHero, "modifier_teleporting") then return true end  	return false  end   local SkipTick = os.clock()  function PudgeBeta1.getComboTarget(myHero)  	if not myHero then return end  	local targetingRange = Menu.GetValue(PudgeBeta1.optionTargetRange) 	local mousePos = Input.GetWorldCursorPos()  	local enemyTable = Wrap.HInRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) 		if #enemyTable < 1 then return end  	local nearestTarget = nil 	local distance = 99999  	for i, v in ipairs(enemyTable) do 		if v and Entity.IsHero(v) then 			if PudgeBeta1.targetChecker(v) ~= nil then 				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D() 				if enemyDist < distance then 					nearestTarget = v 					distance = enemyDist 				end 			end 		end 	end  	return nearestTarget or nil  end  function PudgeBeta1.TargetIndicator(myHero)  	if not myHero then return end  	local curtime = GameRules.GetGameTime()	  	if Menu.GetValue(PudgeBeta1.optionLockTargetParticle) < 2 then 		if PudgeBeta1.LockedTarget ~= nil then 			if curtime > PudgeBeta1.particleNextTime then 				if PudgeBeta1.currentParticle > 0 then 					Particle.Destroy(PudgeBeta1.currentParticle) 					PudgeBeta1.currentParticle = 0 				end 	 				if Menu.GetValue(PudgeBeta1.optionLockTargetParticle) == 0 then 					local sparkParticle = Particle.Create("particles/items_fx/aegis_resspawn_flash.vpcf") 					PudgeBeta1.currentParticle = sparkParticle 			 					Particle.SetControlPoint(sparkParticle, 0, Entity.GetAbsOrigin(PudgeBeta1.LockedTarget)) 				else 					local bloodParticle = Particle.Create("particles/items2_fx/soul_ring_blood.vpcf") 					PudgeBeta1.currentParticle = bloodParticle 					Particle.SetControlPoint(bloodParticle, 0, Entity.GetAbsOrigin(PudgeBeta1.LockedTarget)) 				end  	      		PudgeBeta1.particleNextTime = curtime + 0.35 			end 		end 	else 		if (not PudgeBeta1.LockedTarget or PudgeBeta1.LockedTarget ~= PudgeBeta1.currentParticleTarget) and PudgeBeta1.currentParticle > 0 then 			Particle.Destroy(PudgeBeta1.currentParticle)			 			PudgeBeta1.currentParticle = 0 			PudgeBeta1.currentParticleTarget = PudgeBeta1.LockedTarget 		else 			if PudgeBeta1.currentParticle == 0 and PudgeBeta1.LockedTarget then 				local towerParticle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, PudgeBeta1.LockedTarget)	 				PudgeBeta1.currentParticle = towerParticle 				PudgeBeta1.currentParticleTarget = PudgeBeta1.LockedTarget			 			end 			if PudgeBeta1.currentParticle > 0 then 				Particle.SetControlPoint(PudgeBeta1.currentParticle, 2, Entity.GetOrigin(myHero)) 				Particle.SetControlPoint(PudgeBeta1.currentParticle, 6, Vector(1, 0, 0)) 				Particle.SetControlPoint(PudgeBeta1.currentParticle, 7, Entity.GetOrigin(PudgeBeta1.currentParticleTarget)) 			end 		end 	end  end  function PudgeBeta1.OnPrepareUnitOrders(orders)  	if not orders then return true end 	if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_TRAIN_ABILITY then return true end  	local myHero = Heroes.GetLocal()     		if not myHero then return true end 			 				if Menu.IsEnabled(PudgeBeta1.optionLinkensManual) then 		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then 			if orders.target ~= nil and Entity.IsHero(orders.target) and not Entity.IsSameTeam(myHero, orders.target) then 				if NPC.IsLinkensProtected(orders.target) then 					if PudgeBeta1.LinkensBreakerNew(myHero) ~= nil then 						Ability.CastTarget(NPC.GetItem(myHero, PudgeBeta1.LinkensBreakerNew(myHero), true), orders.target) 						return true 					end 				end 			end 		end 	end 	if Menu.IsEnabled(PudgeBeta1.optionItemVeilManual) then 		local veil = NPC.GetItem(myHero, "item_veil_of_discord", true) 		if veil and Ability.IsReady(veil) then 			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then 				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then 					if not Ability.IsPassive(orders.ability) and Ability.GetCastPoint(orders.ability) > 0.05 then 						if orders.target ~= nil and not Entity.IsDormant(orders.target) and Wrap.EIsAlive(orders.target) and not NPC.IsIllusion(orders.target) then 							Ability.CastPosition(veil, Entity.GetAbsOrigin(orders.target)) 							if not NPC.HasItem(myHero, "item_soul_ring", true) then 								return true 							end 						end 					end 				end 			elseif orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION then 				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then 					if not Ability.IsPassive(orders.ability) and Ability.GetCastPoint(orders.ability) > 0.05 then 						local mousePos = Input.GetWorldCursorPos() 						local checkTarget = nil 							for _, v in ipairs(Wrap.HInRadius(mousePos, 600, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do 								if v and Entity.IsHero(v) and not Entity.IsDormant(v) and Wrap.EIsAlive(v) and not NPC.IsIllusion(v) then 									checkTarget = v 									break 								end 							end  						if checkTarget ~= nil then 							Ability.CastPosition(veil, Entity.GetAbsOrigin(checkTarget)) 							if not NPC.HasItem(myHero, "item_soul_ring", true) then 								return true 							end 						end 					end 				end 			end						 		end 	end  	if Menu.IsEnabled(PudgeBeta1.optionItemSoulringManual) then 		local soulring = NPC.GetItem(myHero, "item_soul_ring", true) 		if soulring and Ability.IsReady(soulring) then 			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION or orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET or 			orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then 				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then 					if not Ability.IsPassive(orders.ability) and Ability.GetManaCost(orders.ability) > 50 and Ability.GetCastPoint(orders.ability) > 0.05 then 						Ability.CastNoTarget(soulring) 						return true 					end 				end 			end 		end 	end  		if PudgeBeta1.myUnitName == "npc_dota_hero_pudge" then 		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION or orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then 			if PudgeBeta1.PudgeHookHit then 				PudgeBeta1.PudgeHookHit = false 			end 		end 	end 	return true end  function PudgeBeta1.utilityRoundNumber(number, digits)  	if not number then return end    	local mult = 10^(digits or 0)   	return math.floor(number * mult + 0.5) / mult  end  function PudgeBeta1.utilityGetTableLength(table)  	if not table then return 0 end 	if next(table) == nil then return 0 end  	local count = 0 	for i, v in pairs(table) do 		count = count + 1 	end  	return count  end  function PudgeBeta1.utilityIsInTable(table, arg)  	if not table then return false end 	if not arg then return false end 	if next(table) == nil then return false end  	for i, v in pairs(table) do 		if i == arg then 			return true 		end 		if type(v) ~= 'table' and v == arg then 			return true 		end 	end  	return false  end  function PudgeBeta1.heroSupported(myHero)  	if not myHero then return end 	local supportedHeroList = PudgeBeta1.heroList  	for _, heroName in pairs(supportedHeroList) do 		if heroName == NPC.GetUnitName(myHero) then 			return true 		end 	end 	return false end  function PudgeBeta1.TimeToFacePosition(myHero, pos)  	if not myHero then return 0 end 	if not pos then return 0 end  	local myPos = Entity.GetAbsOrigin(myHero) 	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()  	local baseVec = (pos - myPos):Normalized()  	local tempProcessing = math.min(baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D()), 1)	  	local checkAngleRad = math.acos(tempProcessing) 	local checkAngle = (180 / math.pi) * checkAngleRad  	local myTurnRate = NPC.GetTurnRate(myHero)  	local turnTime = PudgeBeta1.utilityRoundNumber(((0.033 * math.pi / myTurnRate) / 180) * checkAngle, 3)  	return turntime or 0  end  function PudgeBeta1.setOrderItem(printed)  	PudgeBeta1.ItemCastOrder = {         	{Menu.GetValue(PudgeBeta1.optionItemVeil), "item_veil_of_discord", "position"},         	{Menu.GetValue(PudgeBeta1.optionItemHex), "item_sheepstick", "target"},         	{Menu.GetValue(PudgeBeta1.optionItemBlood), "item_bloodthorn", "target"},         	{Menu.GetValue(PudgeBeta1.optionItemeBlade), "item_ethereal_blade", "target"},         	{Menu.GetValue(PudgeBeta1.optionItemOrchid),"item_orchid", "target"},         	{Menu.GetValue(PudgeBeta1.optionItemAtos),"item_rod_of_atos", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemAbyssal),"item_abyssal_blade", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemHalberd),"item_heavens_halberd", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemShivas),"item_shivas_guard", "no target"}, 		{Menu.GetValue(PudgeBeta1.optionItemDagon),"item_dagon", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemDagon),"item_dagon_2", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemDagon),"item_dagon_3", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemDagon),"item_dagon_4", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemDagon),"item_dagon_5", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemUrn),"item_urn_of_shadows", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemMedallion),"item_medallion_of_courage", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemCrest),"item_solar_crest", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemDiffusal),"item_diffusal_blade", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemSpirit),"item_spirit_vessel", "target"}, 		{Menu.GetValue(PudgeBeta1.optionItemNull),"item_nullifier", "target"},     				}      	table.sort(PudgeBeta1.ItemCastOrder, function(a, b)         	return a[1] > b[1]     	end) 	local printed = false 		if not printed then 			for k,v in ipairs(PudgeBeta1.ItemCastOrder) do 			Log.Write(v[1]..':'..v[2]) 			printed = true 			end 		end end			  function PudgeBeta1.setOrderLinkens(printed) 	 	PudgeBeta1.LinkensBreakerItemOrder = {         	{Menu.GetValue(PudgeBeta1.optionLinkensForce), "item_force_staff"},         	{Menu.GetValue(PudgeBeta1.optionLinkensEul), "item_cyclone"},         	{Menu.GetValue(PudgeBeta1.optionLinkensHalberd), "item_heavens_halberd"},         	{Menu.GetValue(PudgeBeta1.optionLinkensHex), "item_sheepstick"},         	{Menu.GetValue(PudgeBeta1.optionLinkensBlood),"item_bloodthorn"},         	{Menu.GetValue(PudgeBeta1.optionLinkensOrchid),"item_orchid"}, 		{Menu.GetValue(PudgeBeta1.optionLinkensDiffusal),"item_diffusal_blade", "target"}, 		{Menu.GetValue(PudgeBeta1.optionLinkensPike),"item_hurricane_pike"}     				}      	table.sort(PudgeBeta1.LinkensBreakerItemOrder, function(a, b)         	return a[1] > b[1]     	end) 	local printed = false 		if not printed then 			for k,v in ipairs(PudgeBeta1.LinkensBreakerItemOrder) do 			Log.Write(v[1]..':'..v[2]) 			printed = true 			end 		end			 	 end  function PudgeBeta1.OnMenuOptionChange(option, old, new)      	if option == PudgeBeta1.optionItemVeil or 		option == PudgeBeta1.optionItemHex or 		option == PudgeBeta1.optionItemBlood or 		option == PudgeBeta1.optionItemeBlade or  		option == PudgeBeta1.optionItemOrchid or  		option == PudgeBeta1.optionItemAtos or  		option == PudgeBeta1.optionItemAbyssal or  		option == PudgeBeta1.optionItemHalberd or  		option == PudgeBeta1.optionItemShivas or  		option == PudgeBeta1.optionItemDagon or  		option == PudgeBeta1.optionItemUrn or 		option == PudgeBeta1.optionItemManta or 		option == PudgeBeta1.optionItemMjollnir or 		option == PudgeBeta1.optionItemMedallion or 		option == PudgeBeta1.optionItemCrest or 		option == PudgeBeta1.optionItemDiffusal or 		option == PudgeBeta1.optionItemSpirit or 		option == PudgeBeta1.optionItemNull then 			PudgeBeta1.setOrderItem(false) 	end 	 	if option == PudgeBeta1.optionLinkensForce or 		option == PudgeBeta1.optionLinkensEul or 		option == PudgeBeta1.optionLinkensHalberd or 		option == PudgeBeta1.optionLinkensHex or 		option == PudgeBeta1.optionLinkensBlood or 		option == PudgeBeta1.optionLinkensOrchid or 		option == PudgeBeta1.optionLinkensDiffusal or 		option == PudgeBeta1.optionLinkensPike then         		PudgeBeta1.setOrderLinkens(false)     	end end  function PudgeBeta1.targetChecker(genericEnemyEntity)  	local myHero = Heroes.GetLocal() 		if not myHero then return end  	if genericEnemyEntity and not Entity.IsDormant(genericEnemyEntity) and not NPC.IsIllusion(genericEnemyEntity) and Entity.GetHealth(genericEnemyEntity) > 0 then  		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckAM) then 			if NPC.GetUnitName(genericEnemyEntity) == "npc_dota_hero_antimage" and NPC.HasItem(genericEnemyEntity, "item_ultimate_scepter", true) and NPC.HasModifier(genericEnemyEntity, "modifier_antimage_spell_shield") and Ability.IsReady(NPC.GetAbility(genericEnemyEntity, "antimage_spell_shield")) then 				return 			end 		end 		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckLotus) then 			if NPC.HasModifier(genericEnemyEntity, "modifier_item_lotus_orb_active") then 				return 			end 		end 		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckBlademail) then 			if NPC.HasModifier(genericEnemyEntity, "modifier_item_blade_mail_reflect") and Entity.GetHealth(Heroes.GetLocal()) <= 0.25 * Entity.GetMaxHealth(Heroes.GetLocal()) then 				return 			end 		end 		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckNyx) then 			if NPC.HasModifier(genericEnemyEntity, "modifier_nyx_assassin_spiked_carapace") then 				return 			end 		end 		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckUrsa) then 			if NPC.HasModifier(genericEnemyEntity, "modifier_ursa_enrage") then 				return 			end 		end 		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckAbbadon) then 			if NPC.HasModifier(genericEnemyEntity, "modifier_abaddon_borrowed_time") then 				return 			end 		end 		if Menu.IsEnabled(PudgeBeta1.optionTargetCheckDazzle) then 			if NPC.HasModifier(genericEnemyEntity, "modifier_dazzle_shallow_grave") and NPC.GetUnitName(myHero) ~= "npc_dota_hero_axe" then 				return 			end 		end 		if NPC.HasModifier(genericEnemyEntity, "modifier_skeleton_king_reincarnation_scepter_active") then 			return 		end 		if NPC.HasModifier(genericEnemyEntity, "modifier_winter_wyvern_winters_curse") then 			return 		end  	return genericEnemyEntity 	end	 end  function PudgeBeta1.makeDelay(sec)  	PudgeBeta1.delay = sec + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 	PudgeBeta1.lastTick = os.clock()  end  function PudgeBeta1.noItemCastFor(sec)  	PudgeBeta1.itemDelay = sec 	PudgeBeta1.lastItemTick = os.clock()  end  function PudgeBeta1.SleepReady(sleep)  	if (os.clock() - PudgeBeta1.lastTick) >= sleep then 		return true 	end 	return false  end  function PudgeBeta1.ItemSleepReady(sleep)  	if (os.clock() - PudgeBeta1.lastItemCast) >= sleep then 		return true 	end 	return false  end  function PudgeBeta1.GetAvgLatency()  	local AVGlatency = NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2 	return AVGlatency  end  function PudgeBeta1.CastAnimationDelay(ability)  	if not ability then return end  	local abilityAnimation = Ability.GetCastPoint(ability) + PudgeBeta1.GetAvgLatency()  	return abilityAnimation  end 	 function PudgeBeta1.castLinearPrediction(myHero, enemy, adjustmentVariable)  	if not myHero then return end 	if not enemy then return end  	local enemyRotation = Entity.GetRotation(enemy):GetVectors() 		enemyRotation:SetZ(0)     	local enemyOrigin = Entity.GetAbsOrigin(enemy) 		enemyOrigin:SetZ(0)   	local cosGamma = (Entity.GetAbsOrigin(myHero) - enemyOrigin):Dot2D(enemyRotation:Scaled(100)) / ((Entity.GetAbsOrigin(myHero) - enemyOrigin):Length2D() * enemyRotation:Scaled(100):Length2D())  		if enemyRotation and enemyOrigin then 			if not NPC.IsRunning(enemy) then 				return enemyOrigin 			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(PudgeBeta1.GetMoveSpeed(enemy) * adjustmentVariable * (1 - cosGamma))) 			end 		end end  function PudgeBeta1.castPrediction(myHero, enemy, adjustmentVariable)  	if not myHero then return end 	if not enemy then return end  	local enemyRotation = Entity.GetRotation(enemy):GetVectors() 		enemyRotation:SetZ(0)     	local enemyOrigin = Entity.GetAbsOrigin(enemy) 		enemyOrigin:SetZ(0)  	if enemyRotation and enemyOrigin then 			if not NPC.IsRunning(enemy) then 				return enemyOrigin 			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(PudgeBeta1.GetMoveSpeed(enemy) * adjustmentVariable)) 			end 	end end  function PudgeBeta1.isEnemyTurning(enemy)  	if enemy == nil then return true end 	if not NPC.IsRunning(enemy) then return true end 	if NPC.IsTurning(enemy) then return true else return false end 	 	 	if NPC.IsRunning(enemy) then 		table.insert(PudgeBeta1.rotationTable, rotationSpeed) 			if #PudgeBeta1.rotationTable > (Menu.GetValue(PudgeBeta1.optionKillStealInvokerTurn) + 1) then 				table.remove(PudgeBeta1.rotationTable, 1) 			end 	end 	 	if #PudgeBeta1.rotationTable < Menu.GetValue(PudgeBeta1.optionKillStealInvokerTurn) then  		return true 	else 		local rotationSpeedCounter = 0 		i = 1 		repeat 			rotationSpeedCounter = rotationSpeedCounter + PudgeBeta1.rotationTable[#PudgeBeta1.rotationTable + 1 - i] 			i = i + 1 		until i > Menu.GetValue(PudgeBeta1.optionKillStealInvokerTurn)  		if rotationSpeedCounter / Menu.GetValue(PudgeBeta1.optionKillStealInvokerTurn) <= 10 then 			return false 		else 			return true 		end 	end  end  function PudgeBeta1.GetMoveSpeed(enemy)  	if not enemy then return end  	local base_speed = NPC.GetBaseSpeed(enemy) 	local bonus_speed = NPC.GetMoveSpeed(enemy) - NPC.GetBaseSpeed(enemy) 	local modifierHex     	local modSheep = NPC.GetModifier(enemy, "modifier_sheepstick_debuff")     	local modLionVoodoo = NPC.GetModifier(enemy, "modifier_lion_voodoo")     	local modShamanVoodoo = NPC.GetModifier(enemy, "modifier_shadow_shaman_voodoo")  	if modSheep then 		modifierHex = modSheep 	end 	if modLionVoodoo then 		modifierHex = modLionVoodoo 	end 	if modShamanVoodoo then 		modifierHex = modShamanVoodoo 	end  	if modifierHex then 		if math.max(Modifier.GetDieTime(modifierHex) - GameRules.GetGameTime(), 0) > 0 then 			return 140 + bonus_speed 		end 	end      	if NPC.HasModifier(enemy, "modifier_invoker_ice_wall_slow_debuff") then  		return 100  	end  	if NPC.HasModifier(enemy, "modifier_invoker_cold_snap_freeze") or NPC.HasModifier(enemy, "modifier_invoker_cold_snap") then 		return (base_speed + bonus_speed) * 0.5 	end  	if NPC.HasModifier(enemy, "modifier_spirit_breaker_charge_of_darkness") then 		local chargeAbility = NPC.GetAbility(enemy, "spirit_breaker_charge_of_darkness") 		if chargeAbility then 			local specialAbility = NPC.GetAbility(enemy, "special_bonus_unique_spirit_breaker_2") 			if specialAbility then 				 if Ability.GetLevel(specialAbility) < 1 then 					return Ability.GetLevel(chargeAbility) * 50 + 550 				else 					return Ability.GetLevel(chargeAbility) * 50 + 1050 				end 			end 		end 	end 			     	return base_speed + bonus_speed end       function PudgeBeta1.IsInAbilityPhase(myHero)  	if not myHero then return false end  	local myAbilities = {}  	for i= 0, 10 do 		local ability = NPC.GetAbilityByIndex(myHero, i) 		if ability and Entity.IsAbility(ability) and Ability.GetLevel(ability) > 0 then 			table.insert(myAbilities, ability) 		end 	end  	if #myAbilities < 1 then return false end  	for _, v in ipairs(myAbilities) do 		if v then 			if Ability.IsInAbilityPhase(v) then 				return true 			end 		end 	end  	return false  end    function PudgeBeta1.GenericMainAttack(myHero, attackType, target, position) 	 	if not myHero then return end 	if not target and not position then return end  	if PudgeBeta1.isHeroChannelling(myHero) == true then return end 	if PudgeBeta1.heroCanCastItems(myHero) == false then return end 	if PudgeBeta1.IsInAbilityPhase(myHero) == true then return end  end    function PudgeBeta1.itemUsage(myHero, enemy)  	if not myHero then return end 	if not enemy then return end  	if not Menu.IsEnabled(PudgeBeta1.optionItemEnable) then return end 	if (os.clock() - PudgeBeta1.lastItemTick) < PudgeBeta1.itemDelay then return end 	if PudgeBeta1.ItemCastStop then return end  	if PudgeBeta1.heroCanCastItems(myHero) == false then return end 	if PudgeBeta1.isHeroChannelling(myHero) == true then return end 	if PudgeBeta1.IsHeroInvisible(myHero) == true then return end  	if Menu.GetValue(PudgeBeta1.optionItemStyle) == 0 then  		PudgeBeta1.itemUsageNoOrder(myHero, enemy) 	elseif Menu.GetValue(PudgeBeta1.optionItemStyle) == 1 then 		PudgeBeta1.itemUsageOrder(myHero, enemy) 	elseif Menu.GetValue(PudgeBeta1.optionItemStyle) == 2 then 		PudgeBeta1.itemUsageSmartOrder(myHero, enemy) 	end  end  function PudgeBeta1.itemUsageSmartOrder(myHero, enemy, activation)  	if not myHero then return end 	if not enemy then return end  	if PudgeBeta1.heroCanCastItems(myHero) == false then return end 	if PudgeBeta1.isHeroChannelling(myHero) == true then return end 	if PudgeBeta1.IsHeroInvisible(myHero) == true then return end  	local alternateActivation 	if activation == nil then 		alternateActivation = false 	else alternateActivation = activation 	end 	 	local myMana = NPC.GetMana(myHero)  	local soulring = NPC.GetItem(myHero, "item_soul_ring", true) 	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true) 	local manta = NPC.GetItem(myHero, "item_manta", true) 	local dagon = NPC.GetItem(myHero, "item_dagon", true) 		if not dagon then 			for i = 2, 5 do 				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true) 				if dagon then break end 			end 		end  	if (Menu.IsKeyDown(MrGarabato_v1_MenuHx.optionComboKey) or alternateActivation) then 		Player.AttackTarget(Players.GetLocal(), myHero, enemy, false) 		if PudgeBeta1.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(PudgeBeta1.optionItemSoulring) then 			Ability.CastNoTarget(soulring) 			PudgeBeta1.lastItemCast = os.clock() 			return 		end  		if NPC.IsLinkensProtected(enemy) then 			if PudgeBeta1.ItemSleepReady(0.05) and PudgeBeta1.LinkensBreakerNew(myHero) ~= nil then 				Ability.CastTarget(NPC.GetItem(myHero, PudgeBeta1.LinkensBreakerNew(myHero), true), enemy) 				PudgeBeta1.lastItemCast = os.clock() 				return 			end 		end  		if Menu.GetValue(PudgeBeta1.optionItemDagon) == -1 then  			if PudgeBeta1.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then 				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100))) 				local eBladeAMP = 0 					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then 						eBladeAMP = 0.4 					end 				local necroUltDMG = 0 					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then 						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then 							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health") 							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100)) 						end 					end 				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG 				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then 					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then 						Ability.CastTarget(dagon, enemy) 						PudgeBeta1.lastItemCast = os.clock() 						return 					end 				end 			end 		end  		local orderItem 		local customOrder = 0 		local itemActivation  		for k, v in ipairs(PudgeBeta1.ItemCastOrder) do  			local skipItem = 0  			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then 				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or 					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or 					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon" 					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4"  					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest" 					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 						skipItem = v[1] 				end 			end  			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then 				if v[2] ~= "item_nullifier" then 					skipItem = v[1] 				end 			end  			if NPC.HasItem(myHero, v[2], true) then 				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then 					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasModifier(enemy, "modifier_bashed") then 				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 					skipItem = v[1] 				end 			end  			if NPC.HasModifier(enemy, "modifier_stunned") then 				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_stunned")) 				if GameRules.GetGameTime() <= dieTime - 0.1 then 					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then 				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_sheepstick_debuff")) 				if Menu.IsEnabled(PudgeBeta1.optionItemStack) then 					if GameRules.GetGameTime() <= dieTime - 0.1 then 						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 							skipItem = v[1] 						end 					end 				else 					if GameRules.GetGameTime() <= dieTime - 0.1 then 						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 							skipItem = v[1] 						end 					end 				end 			end  			if NPC.HasItem(myHero, "item_sheepstick", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) < 0.5 then 				if Menu.IsEnabled(PudgeBeta1.optionItemStack) then 					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 						skipItem = v[1] 					end 				else 					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 						skipItem = v[1] 					end 				end 			end  			if NPC.IsSilenced(enemy) then 				if NPC.HasModifier(enemy, "modifier_bloodthorn_debuff") then 					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_bloodthorn_debuff")) 					if GameRules.GetGameTime() <= dieTime - 0.1 then 						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then 							skipItem = v[1] 						end 					end 				elseif NPC.HasModifier(enemy, "modifier_orchid_malevolence_debuff") then 					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_orchid_malevolence_debuff")) 					if GameRules.GetGameTime() <= dieTime - 0.1 then 						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then 							skipItem = v[1] 						end 					end 				elseif NPC.HasModifier(enemy, "modifier_silence") then 					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_silence")) 					if GameRules.GetGameTime() <= dieTime - 0.1 then 						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then 							skipItem = v[1] 						end 					end 				end 			end  			if NPC.HasModifier(myHero, "modifier_item_nullifier") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) > -1 and 				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1200) + 0.25 then 				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 					skipItem = v[1] 				end 			end  			if NPC.HasModifier(enemy, "modifier_item_nullifier_mute") then 				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_nullifier_mute")) 				if GameRules.GetGameTime() <= dieTime - 0.1 then 					if  v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasModifier(enemy, "modifier_item_diffusal_blade_slow") then 				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_diffusal_blade_slow")) 				if GameRules.GetGameTime() <= dieTime - 0.1 then 					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasItem(myHero, "item_diffusal_blade", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) < 0.5 then 				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then 					skipItem = v[1] 				end 			end  			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and 				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then 				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4"  					or v[2] == "item_dagon_5" then 					skipItem = v[1] 				end 			end  			if NPC.HasModifier(enemy, "modifier_item_veil_of_discord_debuff") then 				if v[2] == "item_veil_of_discord" then 					skipItem = v[1] 				end 			end		  			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then 				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then 					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasAbility(myHero, "witch_doctor_maledict") then 				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then 					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasAbility(myHero, "pugna_decrepify") then 				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then 					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasItem(enemy, "item_aeon_disk", true) then 				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) < 0 then 					if Entity.GetHealth(enemy) >= 0.85 * Entity.GetMaxHealth(enemy) then 						if v[2] == "item_nullifier" then 							skipItem = v[1] 						end 					end 				end 				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) <= 2.55 then 					if not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then 						if v[2] == "item_nullifier" then 							skipItem = v[1] 						end 					end 				end 			end  			if PudgeBeta1.myUnitName == "npc_dota_hero_tinker" then 				if NPC.IsLinkensProtected(enemy) then 					if v[2] == "item_sheepstick" then 						skipItem = v[1] 					end 				end 			end  			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then 				if v[2] == "item_rod_of_atos" then 					skipItem = v[1] 				end 			end  			if NPC.HasItem(myHero, v[2], true) then 				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then 					orderItem = NPC.GetItem(myHero, v[2], true) 					customOrder = v[1] 					itemActivation = v[3] 				end 			end	 		end 		 			if PudgeBeta1.ItemSleepReady(0.05) and customOrder > 0 then 				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then 					if itemActivation == "target" then 						Ability.CastTarget(orderItem, enemy) 						PudgeBeta1.lastItemCast = os.clock() 						customOrder = 0 						return 					end 					if itemActivation == "no target" then 						Ability.CastNoTarget(orderItem) 						PudgeBeta1.lastItemCast = os.clock() 						customOrder = 0 						return 					end 					if itemActivation == "position" then 						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy)) 						PudgeBeta1.lastItemCast = os.clock() 						customOrder = 0 						return 					end 				end 			end  		if PudgeBeta1.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(PudgeBeta1.optionItemMjollnir) > 0 then 			Ability.CastTarget(mjollnir, myHero) 			PudgeBeta1.lastItemCast = os.clock() 			return 		end  		if PudgeBeta1.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(PudgeBeta1.optionItemManta) > 0 then 			Ability.CastNoTarget(manta) 			PudgeBeta1.lastItemCast = os.clock() 			return 		end 		Player.AttackTarget(Players.GetLocal(), myHero, enemy, false) 	end end  function PudgeBeta1.PudgeHookTargetIndicatorDel(myHero)  	if not myHero then return end  	local curtime = GameRules.GetGameTime()  	if not Menu.IsKeyDown(PudgeBeta1.optionHeroPudgeHookKey) or PudgeBeta1.PudgeHookTarget == nil then 		if PudgeBeta1.PudgecurrentParticle > 0 then 			Particle.Destroy(PudgeBeta1.PudgecurrentParticle)			 			PudgeBeta1.PudgecurrentParticle = 0 		end 	end  	return  end  function PudgeBeta1.AmIFacingPos(myHero, pos, allowedDeviation)  	if not myHero then return false end  	local myPos = Entity.GetAbsOrigin(myHero) 	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()  	local baseVec = (pos - myPos):Normalized()  	local tempProcessing = baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D()) 		if tempProcessing > 1 then 			tempProcessing = 1 		end	  	local checkAngleRad = math.acos(tempProcessing) 	local checkAngle = (180 / math.pi) * checkAngleRad  	if checkAngle < allowedDeviation then 		return true 	end  	return false  end  function PudgeBeta1.PudgeCombo(myHero, enemy) 	local Q = NPC.GetAbilityByIndex(myHero, 0)  	local W = NPC.GetAbilityByIndex(myHero, 1) 	local ult = NPC.GetAbility(myHero, "pudge_dismember")  	local blink = NPC.GetItem(myHero, "item_blink", true) 	local force = NPC.GetItem(myHero, "item_force_staff", true)  	local myMana = NPC.GetMana(myHero)  	PudgeBeta1.itemUsage(myHero, enemy) 	PudgeBeta1.PudgeHookTargetIndicatorDel(myHero)  	local maxInitRange = 0 		if blink and Ability.IsReady(blink) and Menu.IsEnabled(PudgeBeta1.optionHeroPudgeBlink) then 			maxInitRange = maxInitRange + 1200 		end 		if force and Ability.IsCastable(force, myMana) and Menu.IsEnabled(PudgeBeta1.optionHeroPudgeStaff) then 			maxInitRange = maxInitRange + 600 		end 		if enemy then 			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then 				maxInitRange = 0 			end 		end 		if Q and Ability.SecondsSinceLastUse(Q) > -1 and Ability.SecondsSinceLastUse(Q) < 0.5 then 			maxInitRange = 0 		end  	if PudgeBeta1.PudgeRotComboActivation and not Menu.IsKeyDown(MrGarabato_v1_MenuHx.optionComboKey) then 		if Ability.GetToggleState(W) then 			local checkEnemies = false 				for i, v in ipairs(Wrap.HeroesInRadius(myHero, 250, Enum.TeamType.TEAM_ENEMY)) do 					if v and Entity.IsHero(v) and Wrap.EIsAlive(v) and not NPC.IsIllusion(v) then 						checkEnemies = true 						break 					end 				end 				if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < 0.2 then 					checkEnemies = false 				end  			if not checkEnemies then		 				if os.clock() > PudgeBeta1.PudgeRotComboDeactivation then 					Ability.Toggle(W) 					PudgeBeta1.PudgeRotComboActivation = false 					PudgeBeta1.PudgeRotComboDeactivation = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) + 0.05 					return 				end 			end 		end 	end  	if Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHook) then 		if Menu.IsKeyDown(PudgeBeta1.optionHeroPudgeHookKey) then 			local target = PudgeBeta1.PudgeHookGetTarget(myHero) 			if PudgeBeta1.PudgeHookTarget == nil then 				PudgeBeta1.PudgeHookTarget = target 			end 			if PudgeBeta1.PudgeHookTarget ~= nil then 				if Entity.IsHero(PudgeBeta1.PudgeHookTarget) and Wrap.EIsAlive(PudgeBeta1.PudgeHookTarget) then 					PudgeBeta1.PudgeHookCombo(myHero, myMana, PudgeBeta1.PudgeHookTarget, Q, W, ult) 				else 					PudgeBeta1.PudgeHookTarget = nil 				end	 			end 		else 			if PudgeBeta1.PudgeHookTarget ~= nil then 				PudgeBeta1.PudgeHookTarget = nil 			end 		end 	end					  	if enemy and NPC.IsEntityInRange(myHero, enemy, 3000) then 		if Menu.IsKeyDown(MrGarabato_v1_MenuHx.optionComboKey) and Wrap.EIsAlive(enemy) then  			if PudgeBeta1.heroCanCastSpells(myHero, enemy) == true then 				if maxInitRange > 1200 then 					if not NPC.IsEntityInRange(myHero, enemy, 1200) then 						if NPC.IsEntityInRange(myHero, enemy, 1750) then 							Player.AttackTarget(Players.GetLocal(), myHero, enemy, false) 							local pred = 600/1500 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) 							local predPos = PudgeBeta1.castPrediction(myHero, enemy, pred) 							if PudgeBeta1.AmIFacingPos(myHero, predPos, 10) then 								Ability.CastTarget(force, myHero) 								return 							else 								PudgeBeta1.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, predPos) 								return 							end 						end 					else 						if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(PudgeBeta1.optionHeroPudgeBlinkMinRange)) then 							if not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then 								Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75))) 								PudgeBeta1.lastTick = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) 								return 							end 						end 					end 				end 				if maxInitRange == 1200 then 					if NPC.IsEntityInRange(myHero, enemy, 1200) then 						if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(PudgeBeta1.optionHeroPudgeBlinkMinRange)) then 							if not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then 								Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75))) 								PudgeBeta1.lastTick = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) 								return 							end 						end 					end 				end 				if maxInitRange == 600 then 					if NPC.IsEntityInRange(myHero, enemy, 725) then 						if not NPC.IsEntityInRange(myHero, enemy, 550) then 							local pred = 600/1500 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) 							local predPos = PudgeBeta1.castPrediction(myHero, enemy, pred) 							if PudgeBeta1.AmIFacingPos(myHero, predPos, 5) then 								Ability.CastTarget(force, myHero) 								PudgeBeta1.lastTick = os.clock() + 600/1500 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 								return 							else 								PudgeBeta1.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, predPos) 								return 							end 						end 					end 				end  				if PudgeBeta1.PudgeHookCanceller(myHero, enemy) then 					Player.HoldPosition(Players.GetLocal(), myHero, false) 					PudgeBeta1.PudgeHookStartTimer = 0 					PudgeBeta1.lastTick = 0 					PudgeBeta1.PudgeHookTargetedPos = nil 					return 				end	  				if W and Ability.IsReady(W) and NPC.IsEntityInRange(myHero, enemy, 245) and not Ability.GetToggleState(W) then 					if os.clock() > PudgeBeta1.PudgeHookRotDelayer then	 						Ability.Toggle(W) 						PudgeBeta1.PudgeRotComboActivation = true 						PudgeBeta1.PudgeHookRotDelayer = os.clock() + 0.2 						return 					end 				end 	 				if os.clock() > PudgeBeta1.lastTick then  					if ult and Ability.IsCastable(ult, myMana) then 						if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then 							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_HEXED) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_STUNNED) then 								Ability.CastTarget(ult, enemy) 								PudgeBeta1.lastTick = os.clock() + 0.5 								return 							end 						end	 					end  					local check = false 						if maxInitRange == 600 then 							if NPC.IsEntityInRange(myHero, enemy, 725) then 								if not NPC.IsEntityInRange(myHero, enemy, 550) then 									check = true 								end 							end 						end 						if ult and Ability.IsCastable(ult, myMana) then 							if force and Ability.SecondsSinceLastUse(force) > -1 and Ability.SecondsSinceLastUse(force) < 1 then 								check = true 							end 							if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.5 then 								check = true 							end 						end  					if Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHookCombo) and not check and not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then 						if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(PudgeBeta1.optionHeroPudgeHookComboMaxRange)) and not NPC.IsChannellingAbility(myHero) then 							if PudgeBeta1.PudgeHookCollisionChecker(myHero, enemy) and not PudgeBeta1.PudgeHookJukingChecker(myHero, enemy) then 								local hookPrediction = Ability.GetCastPoint(Q) + NPC.GetTimeToFace(myHero, enemy) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) 								local hookPredictedPos = PudgeBeta1.castPrediction(myHero, enemy, hookPrediction) 								Ability.CastPosition(Q, Entity.GetAbsOrigin(myHero) + (hookPredictedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)) 								PudgeBeta1.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, hookPredictedPos) 								PudgeBeta1.PudgeHookTargetedPos = hookPredictedPos 								PudgeBeta1.lastTick = os.clock() + 0.3 								return 							end 						end 					end 				end 			end  			local attCheck = false 				if ult and Ability.IsCastable(ult, myMana) then 					if force and Ability.SecondsSinceLastUse(force) > -1 and Ability.SecondsSinceLastUse(force) < 1 then 						check = true 					end 					if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.5 then 						check = true 					end 				end  			if not NPC.HasModifier(enemy, "modifier_pudge_meat_hook") and not attCheck then 				PudgeBeta1.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil) 				return 			end 		end 	end  	if Menu.IsEnabled(PudgeBeta1.optionHeroPudgeFarm) then 		PudgeBeta1.PudgeAutoFarm(myHero, myMana, W) 	end  	if Menu.IsEnabled(PudgeBeta1.optionHeroPudgeSuicide) then 		PudgeBeta1.PudgeAutoSuicide(myHero, myMana, W) 	end  	return  end  function PudgeBeta1.PudgeAutoSuicide(myHero, myMana, rot)  	if not myHero then return end 	if not rot then return end  	if PudgeBeta1.heroCanCastItems(myHero) == false then return end 	if PudgeBeta1.isHeroChannelling(myHero) == true then return end 	if PudgeBeta1.IsHeroInvisible(myHero) == true then return end  	if os.clock() < PudgeBeta1.PudgeRotFarmToggledTime then return end  	if NPC.HasItem(myHero, "item_armlet", true) then return end  	local rotDamage = Ability.GetLevelSpecialValueFor(rot, "rot_damage") 		if NPC.HasAbility(myHero, "special_bonus_unique_pudge_2") then 			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pudge_2")) > 0 then 				rotDamage = rotDamage + 35 			end 		end  	rotDamage = ((1 - NPC.GetMagicalArmorValue(myHero)) * rotDamage + rotDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) / 4  	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true) 		if soulRing and Ability.IsReady(soulRing) and PudgeBeta1.heroCanCastItems(myHero) then 			rotDamage = rotDamage + 150 		end  	local myHP = Entity.GetHealth(myHero)  	if myHP <= rotDamage then 		for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do 			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then 				if NPC.IsAttacking(v) then 					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then 						if NPC.FindFacingNPC(v) == myHero then 							if soulRing and Ability.IsReady(soulRing) and PudgeBeta1.heroCanCastItems(myHero) then 								Ability.CastNoTarget(soulRing) 								if not Ability.GetToggleState(rot) then 									Ability.Toggle(rot) 								end 								PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 								break 								return 							else 								if not Ability.GetToggleState(rot) then 									Ability.Toggle(rot) 								end 								PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 								break 								return 							end		 						end 					end 				end 				for ability, info in pairs(PudgeBeta1.RawDamageAbilityEstimation) do 					if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then 						local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2]) 						local abilityRadius = info[3] 						if PudgeBeta1.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then 							if next(PudgeBeta1.dodgeItTable) == nil then 								if soulRing and Ability.IsReady(soulRing) and PudgeBeta1.heroCanCastItems(myHero) then 									Ability.CastNoTarget(soulRing) 									if not Ability.GetToggleState(rot) then 										Ability.Toggle(rot) 									end 									PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 									break 									return 								else 									if not Ability.GetToggleState(rot) then 										Ability.Toggle(rot) 									end 									PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 									break 									return 								end 							end 						end 					end 				end 			end	 		end 	end  	return	  end  function PudgeBeta1.IsHeroInvisible(myHero)  	if not myHero then return false end 	if not Wrap.EIsAlive(myHero) then return false end  	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVISIBLE) then return true end 	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return true end 	if NPC.HasAbility(myHero, "invoker_ghost_walk") then 		if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 1 then  			return true 		end 	end  	if NPC.HasItem(myHero, "item_invis_sword", true) then 		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) < 1 then  			return true 		end 	end 	if NPC.HasItem(myHero, "item_silver_edge", true) then 		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) < 1 then  			return true 		end 	end  	return false 		 end  function PudgeBeta1.PudgeAutoFarm(myHero, myMana, rot)  	if not myHero then return end 	if not rot then return end  	if PudgeBeta1.heroCanCastItems(myHero) == false then return end 	if PudgeBeta1.isHeroChannelling(myHero) == true then return end 	if PudgeBeta1.IsHeroInvisible(myHero) == true then return end  	if os.clock() < PudgeBeta1.PudgeRotFarmToggledTime then return end  	if PudgeBeta1.PudgeRotFarmToggled and not Ability.GetToggleState(rot) then 		PudgeBeta1.PudgeRotFarmToggled = false 		return 	end  	if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(PudgeBeta1.optionHeroPudgeFarmHP) / 100 then 		if Ability.GetToggleState(rot) and PudgeBeta1.PudgeRotFarmToggled then 			Ability.Toggle(rot) 			PudgeBeta1.PudgeRotFarmToggled = false 			PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 			return 		else 			return 		end 	end  	local rotDamage = Ability.GetLevelSpecialValueFor(rot, "rot_damage") 		if NPC.HasAbility(myHero, "special_bonus_unique_pudge_2") then 			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pudge_2")) > 0 then 				rotDamage = rotDamage + 35 			end 		end  	if #Wrap.UnitsInRadius(myHero, 240, Enum.TeamType.TEAM_ENEMY) < 1 then 		if Ability.GetToggleState(rot) and PudgeBeta1.PudgeRotFarmToggled then 			Ability.Toggle(rot) 			PudgeBeta1.PudgeRotFarmToggled = false 			PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 			return 		end 	end	  	 	for _, creeps in ipairs(Wrap.UnitsInRadius(myHero, 240, Enum.TeamType.TEAM_ENEMY)) do 		if creeps and Wrap.EIsNPC(creeps) and not Entity.IsHero(creeps) and Wrap.EIsAlive(creeps) and not Entity.IsDormant(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" and NPC.IsCreep(creeps) and NPC.GetUnitName(creeps) ~= nil and NPC.IsKillable(creeps) then 			local rotTrueDamage = ((1 - NPC.GetMagicalArmorValue(creeps)) * rotDamage + rotDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) / 4 			if Entity.GetHealth(creeps) < rotTrueDamage then 				if not Ability.GetToggleState(rot) then 					Ability.Toggle(rot) 					PudgeBeta1.PudgeRotFarmToggled = true 					PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 					return 				end 			else 				if Ability.GetToggleState(rot) and PudgeBeta1.PudgeRotFarmToggled then 					Ability.Toggle(rot) 					PudgeBeta1.PudgeRotFarmToggled = false 					PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 					return 				end 			end 		else 			if Ability.GetToggleState(rot) and PudgeBeta1.PudgeRotFarmToggled then 				Ability.Toggle(rot) 				PudgeBeta1.PudgeRotFarmToggled = false 				PudgeBeta1.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 				return 			end 		end 	end 	 	return 		 end  function PudgeBeta1.PudgeHookCombo(myHero, myMana, npc, hook, rot, ult)  	if not myHero then return end 	if not npc then return end  	if not hook then return end 		if Ability.GetLevel(hook) < 1 then return end  	PudgeBeta1.PudgeHookTargetIndicator(myHero, npc) 	PudgeBeta1.PudgeHookHitTracker(myHero, hook)  	if not Entity.IsSameTeam(myHero, npc) then 		if ult and Ability.IsCastable(ult, myMana) and Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHookUlt) then 			if not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_HEXED) and not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_STUNNED) then 				if os.clock() > PudgeBeta1.PudgeHookDelayer then 					if NPC.IsEntityInRange(myHero, PudgeBeta1.PudgeHookTarget, Ability.GetCastRange(ult)) then 						Ability.CastTarget(ult, PudgeBeta1.PudgeHookTarget) 						PudgeBeta1.PudgeHookDelayer = os.clock() + 0.3 						return 					end 				end 			end 		end  		if rot and Ability.IsReady(rot) and NPC.IsEntityInRange(myHero, PudgeBeta1.PudgeHookTarget, 250) and not Ability.GetToggleState(rot) and Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHookRot) then 			if os.clock() > PudgeBeta1.PudgeHookRotDelayer then 				Ability.Toggle(rot) 				PudgeBeta1.PudgeHookRotDelayer = os.clock() + 0.25 				return 			end 		end  		if PudgeBeta1.PudgeHookHit then 			if Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHookItems) then 				PudgeBeta1.itemUsageSmartOrder(myHero, npc, true) 			end 			if not NPC.HasModifier(npc, "modifier_pudge_meat_hook") then 				PudgeBeta1.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", npc, nil) 			end 		end	 	end  	local hookRange = Ability.GetCastRange(hook) 	local pred = Ability.GetCastPoint(hook) + NPC.GetTimeToFace(myHero, npc) + (Entity.GetAbsOrigin(npc):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) 	local predPos = PudgeBeta1.castPrediction(myHero, npc, pred)  	if not NPC.IsPositionInRange(myHero, predPos, hookRange + 100, 20) then return end  	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)  	if hook and Ability.IsCastable(hook, myMana) and not NPC.IsChannellingAbility(myHero) then  		if PudgeBeta1.PudgeHookCanceller(myHero, npc) then 			Player.HoldPosition(Players.GetLocal(), myHero, false) 			PudgeBeta1.PudgeHookTarget = nil 			PudgeBeta1.PudgeHookStartTimer = 0 			PudgeBeta1.PudgeHookDelayer = 0 			PudgeBeta1.PudgeHookTargetedPos = nil 			return 		end 			 		if os.clock() > PudgeBeta1.PudgeHookDelayer then 			if not PudgeBeta1.PudgeHookJukingChecker(myHero, npc) then 				if PudgeBeta1.PudgeHookCollisionChecker(myHero, npc) then 					if PudgeBeta1.PudgeHookTiming(myHero, npc) > 0 then 						local modTiming = PudgeBeta1.PudgeHookTiming(myHero, npc) + 0.1 						local hookTiming = Ability.GetCastPoint(hook) + NPC.GetTimeToFace(myHero, npc) + ((Entity.GetAbsOrigin(npc):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 125) / 1450) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 						if GameRules.GetGameTime() > modTiming - hookTiming then 							Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)) 							PudgeBeta1.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, predPos) 							PudgeBeta1.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, predPos) 							return	 						end 					else 						if atos and Ability.IsCastable(atos, myMana) and NPC.IsEntityInRange(myHero, npc, 1150) and not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(npc) then 							Ability.CastTarget(atos, npc) 							PudgeBeta1.PudgeHookTarget = npc 							return 						else 							if atos and Ability.SecondsSinceLastUse(atos) > -1 and Ability.SecondsSinceLastUse(atos) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(npc)):Length2D() / 1500) + 0.55 then 								local atosTiming = GameRules.GetGameTime() - math.max(Ability.SecondsSinceLastUse(atos), 0) + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(npc)):Length2D() / 1500) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) - 0.1 								if GameRules.GetGameTime() >= atosTiming then 									Ability.CastPosition(hook, Entity.GetAbsOrigin(npc)) 									PudgeBeta1.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, predPos) 									PudgeBeta1.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, predPos) 									return 								end	 							else 								Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)) 								PudgeBeta1.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, predPos) 								PudgeBeta1.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, predPos) 								PudgeBeta1.PudgeHookTargetedPos = predPos 								return 							end 						end 					end 				else 					if PudgeBeta1.PudgeHookForceStaffFun(myHero, myMana, npc, hook) then 						local targetRotation = Entity.GetRotation(npc):GetForward() 						local targetForcedPos = Entity.GetAbsOrigin(npc) + targetRotation:Normalized():Scaled(600) 						Ability.CastTarget(NPC.GetItem(myHero, "item_force_staff", true), npc) 						PudgeBeta1.PudgeHookTarget = npc 						Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (targetForcedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500), true) 						PudgeBeta1.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, targetForcedPos) 						PudgeBeta1.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + PudgeBeta1.TimeToFacePosition(myHero, targetForcedPos) 						return	 					end 				end 							 			end 		end  	end  end  function PudgeBeta1.PudgeHookCollisionChecker(myHero, target)  	if not myHero then return false end 	if not target then return false end  	local pred = 0.3 + NPC.GetTimeToFace(myHero, target) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) 	local predPos = PudgeBeta1.castPrediction(myHero, target, pred)  	local searchRadius = 125 	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()  	for i = 1, math.floor(distance / searchRadius) do 		local checkVec = (predPos - Entity.GetAbsOrigin(myHero)):Normalized() 		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius) 		local unitsAround = Wrap.NInRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) 		local check = false 			for _, unit in ipairs(unitsAround) do 				if unit and Wrap.EIsNPC(unit) and unit ~= target and unit ~= myHero and Wrap.EIsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then 					check = true 					break 				end 			end  		if check then 			return false 		end	  	end  	return true  end  function PudgeBeta1.PudgeHookCanceller(myHero, target)  	if not myHero then return false end 	if not target then return false end  	local hook = NPC.GetAbilityByIndex(myHero, 0) 		if not hook then return false end 			if Ability.GetLevel(hook) < 1 then return false end  	local hookRange = Ability.GetCastRange(hook)  	if PudgeBeta1.PudgeHookTargetedPos == nil then return false end  	if os.clock() > PudgeBeta1.PudgeHookStartTimer + 0.3 then return false end 	if os.clock() < PudgeBeta1.PudgeHookStartTimer + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then return false end  	local timePassed = math.min(os.clock() - PudgeBeta1.PudgeHookStartTimer, 0.3)  	local pred = (0.3 - timePassed) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) 	local predPos = PudgeBeta1.castPrediction(myHero, target, pred) 	 	if (predPos - Entity.GetAbsOrigin(myHero)):Length2D() > hookRange + 100 then return true end  	local searchRadius = 120 	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()  	local check = false 		for i = 1, math.ceil(distance / searchRadius) do 			local checkVec = (PudgeBeta1.PudgeHookTargetedPos - Entity.GetAbsOrigin(myHero)):Normalized() 			local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius) 			if (checkPos - predPos):Length2D() < searchRadius then 				check = true 				break 			end 		end  	if not check then 		return true 	end  	return false  end  function PudgeBeta1.PudgeHookJukingChecker(myHero, target)  	if not myHero then return false end 	if not target then return false end  	if not NPC.IsRunning(target) then return false end  	local turning = NPC.IsTurning(target)  	if NPC.IsRunning(target) then 		if NPC.IsRunning(target) then 			table.insert(PudgeBeta1.rotationTable, turning) 			if #PudgeBeta1.rotationTable > Menu.GetValue(PudgeBeta1.optionHeroPudgeHookJuke) then 				table.remove(PudgeBeta1.rotationTable, 1) 			end 		end 	end  	if #PudgeBeta1.rotationTable < Menu.GetValue(PudgeBeta1.optionHeroPudgeHookJuke) then  		return true 	else 		local check = false 		for i = 1, #PudgeBeta1.rotationTable do 			if PudgeBeta1.rotationTable[i] == true then 				check = true 				break 			end 		end  		if check then 			return true 		end 	end  	return false   end  function PudgeBeta1.PudgeHookGetTarget(myHero)  	if not myHero then return end  	local targetingRange = Menu.GetValue(PudgeBeta1.optionHeroPudgeHookAcquiRange) 	local mousePos = Input.GetWorldCursorPos()  	 	local enemyTable = Wrap.HInRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) 		if Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHookAllies) then 			enemyTable = Wrap.HInRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) 		end 		if #enemyTable < 1 then return end  	local nearestTarget = nil 	local distance = 99999  	for i, v in ipairs(enemyTable) do 		if v and Entity.IsHero(v) and Wrap.EIsAlive(v) and v ~= myHero then 			if PudgeBeta1.targetChecker(v) ~= nil then 				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D() 				if enemyDist < distance then 					nearestTarget = v 					distance = enemyDist 				end 			end 		end 	end  	return nearestTarget or nil  end  function PudgeBeta1.PudgeHookTiming(myHero, target)  	if not myHero then return 0 end 	if not target then return 0 end  	local invulnerabilityList = { 		"modifier_eul_cyclone", 		"modifier_obsidian_destroyer_astral_imprisonment_prison", 		"modifier_shadow_demon_disruption", 		"modifier_invoker_tornado" 			} 	 	local searchMod 	for _, modifier in ipairs(invulnerabilityList) do 		if NPC.HasModifier(target, modifier) then 			searchMod = NPC.GetModifier(target, modifier) 			break 		end 	end  	if not searchMod then return 0 end  	local timing = 0 	if searchMod then 		local dieTime = Modifier.GetDieTime(searchMod) 		timing = dieTime 	end  	return timing  end  function PudgeBeta1.PudgeHookHitTracker(myHero, hook)  	if not myHero then return end 	if not hook then return end  	if Ability.SecondsSinceLastUse(hook) == -1 and PudgeBeta1.PudgeHookHit then 		PudgeBeta1.PudgeHookHit = false 	end  	if PudgeBeta1.PudgeHookTarget == nil and PudgeBeta1.PudgeHookHit then 		PudgeBeta1.PudgeHookHit = false 	end  	if PudgeBeta1.PudgeHookTarget then 		if NPC.HasModifier(PudgeBeta1.PudgeHookTarget, "modifier_pudge_meat_hook") then 			PudgeBeta1.PudgeHookHit = true 		end 	end 	 	return  end  function PudgeBeta1.heroCanCastSpells(myHero, enemy)  	if not myHero then return false end 	if not Wrap.EIsAlive(myHero) then return false end  	if NPC.IsSilenced(myHero) then return false end  	if NPC.IsStunned(myHero) then return false end 	if NPC.HasModifier(myHero, "modifier_bashed") then return false end 	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	 	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end 	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end 	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	 	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end 	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end 	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end 	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end 	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end 	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end 	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end 	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end 	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end 	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end 	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end 	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end 	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end 	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end 	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end 	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end 	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end  	if enemy then 		if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then return false end 	end  	return true	  end   function PudgeBeta1.PudgeHookForceStaffFun(myHero, myMana, target, hook)  	if not myHero then return false end 	if not target then return false end 		if NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return false end  	if not Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHookStaff) then return false end 	if not hook then return false end  	if PudgeBeta1.heroCanCastSpells(myHero, enemy) == false then return false end 	if PudgeBeta1.isHeroChannelling(myHero) == true then return false end   	if not NPC.IsEntityInRange(myHero, target, 750) then return false end 	if PudgeBeta1.PudgeHookJukingChecker(myHero, target) then return false end  	local force = NPC.GetItem(myHero, "item_force_staff", true) 		if not force then return false end 		if not Ability.IsCastable(force, myMana) then return false end  	local targetTurnTime90 = (0.03 * math.pi) / NPC.GetTurnRate(target) / 3.5 	if NPC.GetTimeToFace(target, myHero) > targetTurnTime90 then return false end  	local targetRotation = Entity.GetRotation(target):GetForward() 	local targetForcedPos = Entity.GetAbsOrigin(target) + targetRotation:Normalized():Scaled(600)  	if not PudgeBeta1.PudgeHookCollisionCheckerPosition(myHero, targetForcedPos) then return false end 	local hookRange = Ability.GetCastRange(hook) 		if (Entity.GetAbsOrigin(myHero) - targetForcedPos):Length2D() > hookRange then return false end  	return true  end  function PudgeBeta1.PudgeHookCollisionCheckerPosition(myHero, pos)  	if not myHero then return false end 	if not pos then return false end  	local searchRadius = 125 	local distance = (Entity.GetAbsOrigin(myHero) - pos):Length2D()  	for i = 1, math.floor(distance / searchRadius) do 		local checkVec = (pos - Entity.GetAbsOrigin(myHero)):Normalized() 		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius) 		local unitsAround = Wrap.NInRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) 		local check = false 			for _, unit in ipairs(unitsAround) do 				if unit and Wrap.EIsNPC(unit) and unit ~= target and unit ~= myHero and Wrap.EIsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then 					check = true 					break 				end 			end  		if check then 			return false 		end	  	end  	return true  end 			 function PudgeBeta1.PudgeHookTargetIndicatorDel(myHero)  	if not myHero then return end  	local curtime = GameRules.GetGameTime()  	if not Menu.IsKeyDown(PudgeBeta1.optionHeroPudgeHookKey) or PudgeBeta1.PudgeHookTarget == nil then 		if PudgeBeta1.PudgecurrentParticle > 0 then 			Particle.Destroy(PudgeBeta1.PudgecurrentParticle)			 			PudgeBeta1.PudgecurrentParticle = 0 		end 	end  	return  end   function PudgeBeta1.PudgeHookTargetIndicator(myHero, target)  	if not myHero then return end 	if not Menu.IsEnabled(PudgeBeta1.optionHeroPudgeHook) then return end  	local curtime = GameRules.GetGameTime() 		 	if (not target or target ~= PudgeBeta1.PudgecurrentParticleTarget) and PudgeBeta1.PudgecurrentParticle > 0 then 		Particle.Destroy(PudgeBeta1.PudgecurrentParticle)			 		PudgeBeta1.PudgecurrentParticle = 0 		PudgeBeta1.PudgecurrentParticleTarget = target 	else 		if PudgeBeta1.PudgecurrentParticle == 0 and target then 			local Particle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, target)	 			PudgeBeta1.PudgecurrentParticle = Particle 			PudgeBeta1.PudgecurrentParticleTarget = target			 		end 		if PudgeBeta1.PudgecurrentParticle > 0 then 			Particle.SetControlPoint(PudgeBeta1.PudgecurrentParticle, 2, Entity.GetOrigin(myHero)) 			Particle.SetControlPoint(PudgeBeta1.PudgecurrentParticle, 6, Vector(1, 0, 0)) 			Particle.SetControlPoint(PudgeBeta1.PudgecurrentParticle, 7, Entity.GetOrigin(PudgeBeta1.PudgecurrentParticleTarget)) 		end 	end end  return PudgeBeta1 			